import psutil
import os
import platform

def bytes_to_human_readable(n_bytes):
    """Конвертирует байты в удобочитаемый формат (KB, MB, GB, TB)."""
    suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
    i = 0
    while n_bytes >= 1024 and i < len(suffixes)-1:
        n_bytes /= 1024.
        i += 1
    # Округляем до 2 знаков после запятой и добавляем суффикс
    f = f'{n_bytes:.2f}'.rstrip('0').rstrip('.')
    return f'{f} {suffixes[i]}'

def get_disk_partitions():
    """Возвращает список доступных дисковых разделов (точек монтирования)."""
    partitions = []
    try:
        # all=False - не включать 'cdrom', 'floppy', etc.
        # Можно поставить all=True, если нужно видеть вообще всё, даже виртуальные
        # или не готовые устройства, но это может запутать пользователя.
        # Попробуем сначала так:
        raw_partitions = psutil.disk_partitions(all=False)
        
        # Дополнительная проверка для Windows, чтобы отсеять "съемные диски" без носителя
        if platform.system() == "Windows":
            for p in raw_partitions:
                 # Пропускаем пустые съемные диски (например, картридер без карты)
                 # Они часто вызывают ошибку 'disk_usage'
                 if 'removable' in p.opts and 'cdrom' not in p.opts:
                     try:
                         # Попытка получить usage может вызвать ошибку, если диск не готов
                         _ = psutil.disk_usage(p.mountpoint) 
                         partitions.append(p)
                     except OSError as e:
                          #print(f"Пропуск {p.mountpoint}: {e}") # Для отладки
                          continue # Пропускаем диск, если он вызвал ошибку доступа
                 else:
                     partitions.append(p)
        else: # Для Linux/macOS оставляем как есть
             partitions = raw_partitions
             
    except Exception as e:
        print(f"Ошибка при получении списка разделов: {e}")
    return partitions

def display_disk_info(partition):
    """Выводит подробную информацию о выбранном разделе."""
    mountpoint = partition.mountpoint
    print(f"\n--- Подробная информация о диске {mountpoint} ---")

    try:
        # 1. Информация об использовании диска
        usage = psutil.disk_usage(mountpoint)
        print("\n[Использование диска]")
        print(f"  Всего места:    {bytes_to_human_readable(usage.total)} ({usage.total} байт)")
        print(f"  Использовано:   {bytes_to_human_readable(usage.used)} ({usage.used} байт)")
        print(f"  Свободно:       {bytes_to_human_readable(usage.free)} ({usage.free} байт)")
        try:
            # Процент использования может быть неточным для некоторых систем/дисков
            percent_used = usage.percent
            print(f"  Загруженность:  {percent_used:.1f}%")
        except Exception:
            print("  Загруженность:  Не удалось рассчитать процент.")

        # 2. Информация о разделе (из disk_partitions)
        print("\n[Техническая информация о разделе]")
        print(f"  Точка монтирования: {partition.mountpoint}")
        print(f"  Устройство:         {partition.device or 'N/A'}") # Имя устройства (может быть пустым)
        print(f"  Файловая система:   {partition.fstype or 'N/A'}")
        print(f"  Опции монтирования: {partition.opts or 'N/A'}") # Например, 'rw,fixed'

        # 3. Информация о пользователе (Владелец корневой папки диска)
        # ВНИМАНИЕ: Это НЕ список всех пользователей системы или тех, кто имеет файлы на диске.
        # Это владелец самой точки монтирования (например, C:\). Обычно это 'SYSTEM' или 'root'.
        # Получение полного списка пользователей, имеющих файлы на диске, - сложная и долгая задача.
        print("\n[Информация о владельце]")
        try:
             # На Windows может потребоваться установка модуля 'pywin32' для os.stat
             # pip install pywin32 
             # На Linux/macOS это обычно работает из коробки
             stat_info = os.stat(mountpoint)
             owner_uid = stat_info.st_uid
             owner_gid = stat_info.st_gid
             
             owner_name = str(owner_uid) # По умолчанию показываем UID
             group_name = str(owner_gid) # По умолчанию показываем GID

             # Попробуем получить имена пользователя/группы, если возможно
             if platform.system() != "Windows": # На Linux/macOS
                try:
                    import pwd
                    owner_name = pwd.getpwuid(owner_uid).pw_name
                except (ImportError, KeyError):
                    pass # Модуль pwd недоступен или UID не найден
                try:
                    import grp
                    group_name = grp.getgrgid(owner_gid).gr_name
                except (ImportError, KeyError):
                     pass # Модуль grp недоступен или GID не найден
             else: # На Windows попробуем через win32security (если pywin32 установлен)
                 try:
                     import win32security
                     import ntsecuritycon as con
                     sd = win32security.GetFileSecurity(mountpoint, win32security.OWNER_SECURITY_INFORMATION)
                     owner_sid = sd.GetSecurityDescriptorOwner()
                     name, domain, type = win32security.LookupAccountSid(None, owner_sid)
                     owner_name = f"{domain}\\{name}"
                     # Получение группы сложнее и менее стандартизировано для корня диска
                     group_name = "N/A (Windows)" 
                 except ImportError:
                    # print("Для получения имени владельца в Windows установите 'pywin32'")
                    pass # Модуль не установлен
                 except Exception as win_err:
                    # print(f"Ошибка получения владельца Windows: {win_err}") # Отладка
                    pass # Другая ошибка win32

             print(f"  Владелец точки монтирования: {owner_name} (UID: {owner_uid})")
             print(f"  Группа точки монтирования:  {group_name} (GID: {owner_gid})")
             
        except Exception as e:
            print(f"  Не удалось получить информацию о владельце: {e}")
            
        # 4. Другая системная информация (если доступна через psutil)
        # Например, статистика ввода/вывода (может требовать прав администратора)
        print("\n[Статистика ввода/вывода (если доступно)]")
        try:
            io_counters = psutil.disk_io_counters(perdisk=True)
            # Нам нужно найти ключ, соответствующий нашему устройству.
            # Это может быть сложно, т.к. имена в io_counters могут отличаться от partition.device
            # Например, 'PhysicalDrive0' в Windows vs 'C:\\'
            # Попробуем найти по началу имени устройства, если оно есть
            
            disk_name = None
            if partition.device:
                # Простой вариант для Linux/macOS (типа /dev/sda1 -> sda1)
                if platform.system() != "Windows":
                    disk_name = os.path.basename(partition.device)
                    # Иногда имя диска - это просто число (например, nvme0n1p2 -> nvme0n1)
                    import re
                    match = re.match(r'^([a-zA-Z]+[0-9]+)', disk_name) 
                    if match:
                        disk_name = match.group(1) 
                else: 
                    # Для Windows это сложнее, имя устройства C:\ не соответствует имени в disk_io_counters
                    # Пропустим пока точное сопоставление для Windows для простоты
                    pass 
            
            found_io = False
            if disk_name and disk_name in io_counters:
                counters = io_counters[disk_name]
                print(f"  Статистика для '{disk_name}':")
                print(f"    Чтений:       {counters.read_count}")
                print(f"    Записей:      {counters.write_count}")
                print(f"    Байт прочитано: {bytes_to_human_readable(counters.read_bytes)}")
                print(f"    Байт записано:  {bytes_to_human_readable(counters.write_bytes)}")
                if hasattr(counters, 'read_time'): # Доступно не на всех ОС
                     print(f"    Время чтения (мс): {counters.read_time}")
                if hasattr(counters, 'write_time'): # Доступно не на всех ОС
                     print(f"    Время записи (мс): {counters.write_time}")
                found_io = True
            
            if not found_io:
                 print("  Подробная статистика ввода/вывода для этого раздела не найдена или не поддерживается.")
                 # print("  Доступные счетчики IO:", list(io_counters.keys())) # Для отладки

        except PermissionError:
             print("  Недостаточно прав для доступа к статистике ввода/вывода.")
        except Exception as e:
             print(f"  Не удалось получить статистику ввода/вывода: {e}")


    except FileNotFoundError:
        print(f"Ошибка: Диск или точка монтирования '{mountpoint}' не найдена.")
        print("Возможно, диск был отключен после запуска скрипта.")
    except PermissionError:
        print(f"Ошибка: Недостаточно прав для доступа к информации о диске '{mountpoint}'.")
        print("Попробуйте запустить скрипт от имени администратора (или с sudo).")
    except Exception as e:
        print(f"Произошла непредвиденная ошибка при получении информации о {mountpoint}: {e}")

    print(f"\n--- Конец информации о {mountpoint} ---")


if __name__ == "__main__":
    print("Поиск подключенных дисков...")
    available_partitions = get_disk_partitions()

    if not available_partitions:
        print("Не найдено доступных дисковых разделов.")
    else:
        print("\nДоступные диски:")
        for i, p in enumerate(available_partitions):
            # Попробуем добавить размер диска для наглядности
            try:
                usage = psutil.disk_usage(p.mountpoint)
                size_info = f"({bytes_to_human_readable(usage.total)})"
            except Exception:
                size_info = "(размер не определен)"
            print(f"  {i + 1}. {p.mountpoint}  {size_info} [{p.fstype or 'N/A'}]")

        while True:
            try:
                choice = input(f"\nВведите номер диска (1-{len(available_partitions)}), чтобы получить информацию, или 0 для выхода: ")
                choice_num = int(choice)

                if choice_num == 0:
                    print("Выход.")
                    break
                
                if 1 <= choice_num <= len(available_partitions):
                    selected_partition = available_partitions[choice_num - 1]
                    display_disk_info(selected_partition)
                    # Можно добавить опцию повторного выбора или выхода здесь
                    # input("\nНажмите Enter для продолжения...") # Раскомментировать, если нужно пауза
                    # break # Раскомментировать, если нужно выйти после одного выбора
                else:
                    print(f"Неверный номер. Пожалуйста, введите число от 1 до {len(available_partitions)} или 0.")

            except ValueError:
                print("Неверный ввод. Пожалуйста, введите число.")
            except KeyboardInterrupt:
                print("\nВыход по запросу пользователя.")
                break
