import socket
import psutil
import os
import subprocess
import platform
import re
import requests
# netifaces больше не нужен
from colorama import Fore, Style, init

# Инициализация colorama (сбрасывает цвет после каждого print)
init(autoreset=True)

def get_network_interfaces():
    """Получает информацию о сетевых интерфейсах (IP, MAC)."""
    interfaces = {}
    try:
        addrs = psutil.net_if_addrs()
        stats = psutil.net_if_stats() # Получаем статус интерфейсов

        for name, snic_list in addrs.items():
            interfaces[name] = {'ip_v4': None, 'ip_v6': None, 'mac': None, 'is_up': False, 'speed': 0}
            if name in stats:
                interfaces[name]['is_up'] = stats[name].isup
                interfaces[name]['speed'] = stats[name].speed

            for snic in snic_list:
                if snic.family == socket.AF_INET:
                    interfaces[name]['ip_v4'] = snic.address
                elif snic.family == socket.AF_INET6:
                    interfaces[name]['ip_v6'] = snic.address
                # В psutil адрес MAC часто имеет семейство AF_LINK или специфичное для платформы
                elif hasattr(psutil, 'AF_LINK') and snic.family == psutil.AF_LINK:
                     interfaces[name]['mac'] = snic.address
                # Для Windows MAC может не иметь AF_LINK, проверяем по длине
                elif platform.system() == "Windows" and len(snic.address) == 17 and snic.address.count('-') == 5 :
                     interfaces[name]['mac'] = snic.address.replace('-',':').lower() # Приводим к стандартному виду
                # Иногда MAC может быть и в AF_PACKET на Linux
                elif platform.system() == "Linux" and hasattr(socket, 'AF_PACKET') and snic.family == socket.AF_PACKET:
                     interfaces[name]['mac'] = snic.address

    except Exception as e:
        print(f"{Fore.RED}Ошибка при получении информации об интерфейсах: {e}")
    return interfaces

def get_wifi_details():
    """Пытается получить SSID и силу сигнала текущего Wi-Fi соединения."""
    system = platform.system()
    wifi_info = {'ssid': None, 'signal_strength': None}

    try:
        if system == "Windows":
            # Используем netsh для получения информации о Wi-Fi
            result = subprocess.check_output(['netsh', 'wlan', 'show', 'interfaces'], shell=True, text=True, encoding='cp866', errors='ignore')
            ssid_match = re.search(r"SSID\s+:\s(.*)", result)
            signal_match = re.search(r"Сигнал\s+:\s(\d+)%", result) # Ищем "Сигнал" для русской Windows
            if not signal_match:
                 signal_match = re.search(r"Signal\s+:\s(\d+)%", result) # Ищем "Signal" для английской

            if ssid_match:
                wifi_info['ssid'] = ssid_match.group(1).strip()
            if signal_match:
                wifi_info['signal_strength'] = f"{signal_match.group(1)}%"

        elif system == "Linux":
            try:
                # Пытаемся использовать iwconfig
                result = subprocess.check_output(['iwconfig'], shell=True, text=True, errors='ignore')
                ssid_match = re.search(r'ESSID:"([^"]+)"', result)
                signal_match = re.search(r'Signal level=([-\d]+)\s+dBm', result)
                quality_match = re.search(r'Link Quality=(\d+)/(\d+)', result) # Качество связи как альтернатива

                if ssid_match:
                    wifi_info['ssid'] = ssid_match.group(1)
                if signal_match:
                     wifi_info['signal_strength'] = f"{signal_match.group(1)} dBm"
                elif quality_match:
                     try:
                         quality = int(quality_match.group(1))
                         total = int(quality_match.group(2))
                         percent = int((quality / total) * 100)
                         wifi_info['signal_strength'] = f"{percent}% ({quality}/{total})"
                     except ValueError:
                         pass # Не удалось преобразовать в числа

            except FileNotFoundError:
                 print(f"{Fore.YELLOW}Команда 'iwconfig' не найдена. Попробуйте установить wireless-tools.")
            except subprocess.CalledProcessError:
                 print(f"{Fore.YELLOW}Не удалось выполнить 'iwconfig'. Возможно, нет активного Wi-Fi интерфейса.")


        elif system == "Darwin": # macOS
            try:
                # Используем airport утилиту
                airport_path = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
                if os.path.exists(airport_path):
                     result = subprocess.check_output([airport_path, '-I'], shell=False, text=True, errors='ignore')
                     ssid_match = re.search(r"\s+SSID:\s(.*)", result)
                     signal_match = re.search(r"\s+agrCtlRSSI:\s(.*)", result) # RSSI как показатель сигнала

                     if ssid_match:
                         wifi_info['ssid'] = ssid_match.group(1).strip()
                     if signal_match:
                         wifi_info['signal_strength'] = f"{signal_match.group(1)} dBm (RSSI)"
                else:
                    print(f"{Fore.YELLOW}Утилита 'airport' не найдена по стандартному пути.")
            except (FileNotFoundError, subprocess.CalledProcessError) as e:
                 print(f"{Fore.YELLOW}Не удалось получить информацию Wi-Fi через airport: {e}")

    except Exception as e:
        print(f"{Fore.RED}Ошибка при получении деталей Wi-Fi: {e}")

    # Возвращаем только если есть хоть какая-то информация
    if wifi_info['ssid'] or wifi_info['signal_strength']:
        return wifi_info
    else:
        return None

# --- НОВАЯ ФУНКЦИЯ для получения шлюза без netifaces ---
def get_default_gateway():
    """Получает шлюз по умолчанию, используя системные команды."""
    system = platform.system()
    gateway = None
    try:
        if system == "Windows":
            # Используем 'route print' и ищем строку с 0.0.0.0
            # -4 указывает искать только IPv4 маршруты
            result = subprocess.check_output(['route', 'print', '-4'], shell=True, text=True, encoding='cp866', errors='ignore')
            # Ищем строку вида: "0.0.0.0          0.0.0.0      <Шлюз>      <IP интерфейса>"
            match = re.search(r'^\s*0\.0\.0\.0\s+0\.0\.0\.0\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+', result, re.MULTILINE)
            if match:
                gateway = match.group(1)

        elif system == "Linux":
            # Используем 'ip route show default'
            result = subprocess.check_output(['ip', 'route', 'show', 'default'], shell=False, text=True, encoding='utf-8', errors='ignore')
            # Ищем строку вида: "default via <Шлюз> dev <Интерфейс>"
            match = re.search(r'default via (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', result)
            if match:
                gateway = match.group(1)

        elif system == "Darwin": # macOS
            # Используем 'netstat -nr | grep default'
            result = subprocess.check_output(['netstat', '-nr'], shell=False, text=True, encoding='utf-8', errors='ignore')
            # Ищем строку, начинающуюся с 'default', второй столбец - шлюз
            match = re.search(r'^default\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+', result, re.MULTILINE)
            if match:
                gateway = match.group(1)
            # Альтернатива для macOS: 'route -n get default | grep gateway'
            # try:
            #     result_route = subprocess.check_output(['route', '-n', 'get', 'default'], shell=False, text=True, encoding='utf-8', errors='ignore')
            #     match_route = re.search(r'gateway:\s*(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', result_route)
            #     if match_route:
            #         gateway = match_route.group(1)
            # except (FileNotFoundError, subprocess.CalledProcessError):
            #     pass # Если route не сработал, полагаемся на netstat

    except FileNotFoundError:
        print(f"{Fore.YELLOW}Команда для определения шлюза не найдена в системе.")
    except subprocess.CalledProcessError as e:
        print(f"{Fore.YELLOW}Ошибка выполнения команды для определения шлюза: {e}")
    except Exception as e:
        print(f"{Fore.RED}Ошибка при получении шлюза: {e}")

    return gateway
# --- Конец НОВОЙ ФУНКЦИИ ---

def get_dns_servers():
    """Пытается получить DNS-серверы."""
    dns_servers = []
    system = platform.system()
    try:
        if system == "Windows":
            # Парсим вывод ipconfig /all
            result = subprocess.check_output(['ipconfig', '/all'], shell=True, text=True, encoding='cp866', errors='ignore')
            dns_matches = re.findall(r"DNS-серверы.*:\s+([\d\.\s]+(?:\n\s+[\d\.]+)*)", result)
            if not dns_matches: # Для английской версии
                dns_matches = re.findall(r"DNS Servers.*:\s+([\d\.\s]+(?:\n\s+[\d\.]+)*)", result)

            for match in dns_matches:
                 # Разделяем адреса, убираем пустые строки и пробелы
                 servers = [ip.strip() for ip in re.split(r'\s+', match) if ip.strip() and ip.strip() != '::1'] # Исключаем локальный IPv6 адрес
                 dns_servers.extend(servers)

        elif system == "Linux":
            # Читаем /etc/resolv.conf
            try:
                with open("/etc/resolv.conf", "r") as f:
                    for line in f:
                        if line.strip().startswith("nameserver"):
                            parts = line.strip().split()
                            if len(parts) > 1:
                                dns_servers.append(parts[1])
            except FileNotFoundError:
                print(f"{Fore.YELLOW}/etc/resolv.conf не найден.")

        elif system == "Darwin": # macOS
             # Используем scutil --dns
             result = subprocess.check_output(['scutil', '--dns'], shell=False, text=True, errors='ignore')
             resolver_matches = re.findall(r"nameserver\[\d+\]\s+:\s+([\d\.]+)", result)
             dns_servers.extend(resolver_matches)

    except FileNotFoundError:
        print(f"{Fore.YELLOW}Команда для определения DNS не найдена.")
    except subprocess.CalledProcessError as e:
        print(f"{Fore.YELLOW}Ошибка выполнения команды для определения DNS: {e}")
    except Exception as e:
        print(f"{Fore.RED}Ошибка при получении DNS-серверов: {e}")

    # Убираем дубликаты, сохраняя порядок (если важно) или просто уникальные
    # Исключаем локальные адреса вроде 127.0.0.1 если они попали
    unique_dns = []
    for server in dns_servers:
        if server not in unique_dns and server != '127.0.0.1':
            unique_dns.append(server)
    return unique_dns


def get_external_ip():
    """Получает внешний IP-адрес."""
    try:
        response = requests.get('https://api.ipify.org?format=json', timeout=5)
        response.raise_for_status() # Проверка на ошибки HTTP
        return response.json().get('ip')
    except requests.exceptions.RequestException as e:
        print(f"{Fore.RED}Не удалось получить внешний IP: {e}")
    except Exception as e:
         print(f"{Fore.RED}Ошибка при получении внешнего IP: {e}")
    return None

def get_active_connections():
    """Получает список активных сетевых соединений."""
    connections = []
    try:
        conns = psutil.net_connections(kind='inet') # inet = TCP/UDP IPv4/IPv6
        for conn in conns:
            conn_info = {
                'local_addr': f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else "N/A",
                'remote_addr': f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else "N/A",
                'status': conn.status,
                'pid': conn.pid or 'N/A'
            }
            # Попробуем получить имя процесса по PID
            try:
                if conn.pid is not None: # Проверяем, что PID не None
                    proc = psutil.Process(conn.pid)
                    conn_info['process_name'] = proc.name()
                # Системные процессы (PID 0 в Windows, может быть иначе в Linux)
                elif conn.pid == 0 and platform.system() == "Windows":
                     conn_info['process_name'] = 'System'
                else:
                    conn_info['process_name'] = 'N/A'
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                 conn_info['process_name'] = 'N/A (Нет доступа)' if conn.pid is not None else 'N/A'
            except psutil.ZombieProcess:
                conn_info['process_name'] = 'Zombie Process'


            connections.append(conn_info)
    except Exception as e:
        print(f"{Fore.RED}Ошибка при получении активных соединений: {e}")
    return connections

# --- Основное выполнение ---
if __name__ == "__main__":
    print(f"{Style.BRIGHT}{Fore.CYAN}--- Информация о сетевых интерфейсах ---{Style.RESET_ALL}")
    interfaces = get_network_interfaces()
    if interfaces:
        for name, info in interfaces.items():
            status = f"{Fore.GREEN}UP" if info['is_up'] else f"{Fore.RED}DOWN"
            speed = f"{info['speed']} Mbps" if info['speed'] else "N/A"
            print(f"{Fore.YELLOW}Интерфейс: {Style.BRIGHT}{name}{Style.RESET_ALL}")
            print(f"  Статус: {status}")
            print(f"  Скорость: {speed}")
            print(f"  MAC адрес: {Fore.GREEN}{info.get('mac', 'N/A')}")
            print(f"  IPv4 адрес: {Fore.GREEN}{info.get('ip_v4', 'N/A')}")
            print(f"  IPv6 адрес: {Fore.GREEN}{info.get('ip_v6', 'N/A')}")
            print("-" * 20)
    else:
        print(f"{Fore.YELLOW}Не удалось получить информацию об интерфейсах.")

    print(f"\n{Style.BRIGHT}{Fore.CYAN}--- Детали Wi-Fi соединения ---{Style.RESET_ALL}")
    wifi_details = get_wifi_details()
    if wifi_details:
        print(f"  Имя сети (SSID): {Fore.GREEN}{wifi_details.get('ssid', 'N/A')}")
        print(f"  Сила сигнала: {Fore.GREEN}{wifi_details.get('signal_strength', 'N/A')}")
        print(f"{Fore.MAGENTA}  Пароль: {Style.BRIGHT}Невозможно получить из соображений безопасности.{Style.RESET_ALL}")
    else:
        print(f"{Fore.YELLOW}Детали Wi-Fi не найдены или не применимы.")

    print(f"\n{Style.BRIGHT}{Fore.CYAN}--- Основные сетевые параметры ---{Style.RESET_ALL}")
    gateway = get_default_gateway() # Используем новую функцию
    print(f"  Шлюз по умолчанию: {Fore.GREEN}{gateway if gateway else 'N/A'}")

    dns = get_dns_servers()
    print(f"  DNS серверы: {Fore.GREEN}{', '.join(dns) if dns else 'N/A'}")

    external_ip = get_external_ip()
    print(f"  Внешний IP адрес: {Fore.GREEN}{external_ip if external_ip else 'N/A'}")

    print(f"\n{Style.BRIGHT}{Fore.CYAN}--- Активные сетевые соединения (TCP/UDP) ---{Style.RESET_ALL}")
    connections = get_active_connections()
    if connections:
        # Выводим только первые N соединений, чтобы не засорять вывод
        max_connections_to_show = 20
        print(f"{Fore.WHITE}{Style.BRIGHT}{'Локальный адрес':<25} {'Удаленный адрес':<25} {'Статус':<15} {'PID':<8} {'Процесс'}{Style.RESET_ALL}")
        print("-" * 80)
        count = 0
        for conn in connections:
             # Пропускаем LISTEN соединения без удаленного адреса для краткости, если их много
             if conn['status'] == psutil.CONN_LISTEN and conn['remote_addr'] == 'N/A' and len(connections) > max_connections_to_show * 2 :
                 continue

             # Выводим информацию
             local = conn['local_addr'] if conn['local_addr'] != 'N/A' else " " * 25
             remote = conn['remote_addr'] if conn['remote_addr'] != 'N/A' else " " * 25
             status = conn['status'] if conn['status'] not in ('NONE', None) else 'UDP' # Отображаем UDP если статус NONE или пустой
             pid = str(conn['pid'])
             pname = conn.get('process_name', 'N/A')

             # Укорачиваем длинные имена процессов
             if len(pname) > 25:
                 pname = pname[:22] + "..."

             print(f"{Fore.CYAN}{local:<25} {Fore.YELLOW}{remote:<25} {Fore.GREEN}{status:<15} {Fore.MAGENTA}{pid:<8} {Fore.WHITE}{pname}")

             count += 1
             if count >= max_connections_to_show and len(connections) > max_connections_to_show :
                 print(f"{Fore.LIGHTBLACK_EX}... и еще {len(connections) - count} соединений ...{Style.RESET_ALL}")
                 break # Прерываем вывод после достижения лимита
    else:
        print(f"{Fore.YELLOW}Не удалось получить информацию об активных соединениях.")
