import psutil
import platform
import socket
import datetime
import os
import sys

# --- Вспомогательные функции для форматирования ---

def get_size(bytes_val, suffix="B"):
    """
    Масштабирование байтов до удобного формата (KB, MB, GB, TB, PB).
    """
    factor = 1024
    for unit in ["", "K", "M", "G", "T", "P"]:
        if bytes_val < factor:
            return f"{bytes_val:.2f}{unit}{suffix}"
        bytes_val /= factor
    return f"{bytes_val:.2f}P{suffix}" # На случай очень больших значений

def format_timedelta(td):
    """Форматирует объект timedelta в читаемый вид (дни, часы, минуты, секунды)"""
    total_seconds = int(td.total_seconds())
    days, remainder = divmod(total_seconds, 86400)
    hours, remainder = divmod(remainder, 3600)
    minutes, seconds = divmod(remainder, 60)
    parts = []
    if days > 0:
        parts.append(f"{days} дн")
    if hours > 0:
        parts.append(f"{hours} ч")
    if minutes > 0:
        parts.append(f"{minutes} мин")
    if seconds > 0 or not parts: # Показываем секунды, если нет других частей
         parts.append(f"{seconds} сек")
    return ", ".join(parts)


# --- Функции для сбора информации по разделам ---

def get_system_info():
    """Собирает основную информацию о системе."""
    print("="*40, "Конфигурация Системы", "="*40)
    uname = platform.uname()
    boot_time_timestamp = psutil.boot_time()
    bt = datetime.datetime.fromtimestamp(boot_time_timestamp)
    uptime = datetime.datetime.now() - bt

    print(f"Система:            {uname.system}")
    print(f"Имя узла:           {uname.node}")
    print(f"Версия:             {uname.release}")
    print(f"Полная версия:      {uname.version}")
    print(f"Архитектура:        {uname.machine}")
    print(f"Процессор:          {uname.processor}")
    print(f"Версия Python:      {platform.python_version()}")
    print(f"Время загрузки:     {bt.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Время работы:       {format_timedelta(uptime)}")
    print("-" * 105) # Разделитель

def get_cpu_info():
    """Собирает информацию о CPU."""
    print("="*40, "Информация о CPU", "="*40)
    # Физические ядра
    physical_cores = psutil.cpu_count(logical=False)
    # Логические ядра (потоки)
    logical_cores = psutil.cpu_count(logical=True)
    print(f"Физические ядра:    {physical_cores}")
    print(f"Логические ядра:    {logical_cores}")

    # Частота CPU
    cpufreq = psutil.cpu_freq()
    if cpufreq: # Не на всех системах доступно
      print(f"Макс. частота:      {cpufreq.max:.2f} МГц")
      print(f"Мин. частота:       {cpufreq.min:.2f} МГц")
      print(f"Текущая частота:    {cpufreq.current:.2f} МГц")
    else:
      print("Частота CPU:        Не удалось определить")

    # Загрузка CPU
    print("Загрузка CPU по ядрам:")
    for i, percentage in enumerate(psutil.cpu_percent(percpu=True, interval=1)):
        print(f"  Ядро {i}: {percentage}%")
    total_cpu_usage = psutil.cpu_percent(interval=1) # Интервал важен для точности
    print(f"Общая загрузка CPU: {total_cpu_usage}%")
    print("-" * 105)
    return total_cpu_usage # Возвращаем общую загрузку для анализа

def get_memory_info():
    """Собирает информацию об оперативной памяти (RAM)."""
    print("="*40, "Информация о Памяти (RAM)", "="*40)
    svmem = psutil.virtual_memory()
    print(f"Всего:              {get_size(svmem.total)}")
    print(f"Доступно:           {get_size(svmem.available)}")
    print(f"Использовано:       {get_size(svmem.used)}")
    print(f"Процент занятости:  {svmem.percent}%")

    # Информация о SWAP (если есть)
    swap = psutil.swap_memory()
    if swap.total > 0: # Показываем SWAP только если он используется
        print("-" * 20, "SWAP", "-" * 20)
        print(f"  Всего:            {get_size(swap.total)}")
        print(f"  Свободно:         {get_size(swap.free)}")
        print(f"  Использовано:     {get_size(swap.used)}")
        print(f"  Процент занятости:{swap.percent}%")
    print("-" * 105)
    return svmem.percent # Возвращаем процент использования RAM для анализа

def get_disk_info():
    """Собирает информацию о дисковых разделах."""
    print("="*40, "Информация о Дисках", "="*40)
    partitions = psutil.disk_partitions()
    disk_usage_list = []
    for partition in partitions:
        # Пропускаем некоторые типы файловых систем и устройства,
        # которые могут вызвать ошибки доступа или не являются обычными дисками
        # (особенно актуально для Linux с его /dev/loop, squashfs и т.д.)
        if "cdrom" in partition.opts or partition.fstype == '' \
           or (sys.platform.startswith("linux") and \
               ("squashfs" in partition.fstype or "/snap/" in partition.mountpoint)):
             continue

        print(f"--- Устройство: {partition.device} ---")
        print(f"  Точка монтирования: {partition.mountpoint}")
        print(f"  Файловая система:   {partition.fstype}")
        try:
            partition_usage = psutil.disk_usage(partition.mountpoint)
            total = get_size(partition_usage.total)
            used = get_size(partition_usage.used)
            free = get_size(partition_usage.free)
            percent = partition_usage.percent

            print(f"  Общий объем:        {total}")
            print(f"  Использовано:       {used}")
            print(f"  Свободно:           {free}")
            print(f"  Процент занятости:  {percent}%")

            disk_usage_list.append({
                "mountpoint": partition.mountpoint,
                "percent": percent,
                "total": total,
                "used": used
            })

        except PermissionError:
            print(f"  Не удалось получить информацию о использовании (ошибка доступа) для {partition.mountpoint}")
        except FileNotFoundError:
             print(f"  Не удалось получить информацию о использовании (диск/раздел не найден?) для {partition.mountpoint}")
        except Exception as e:
            print(f"  Не удалось получить информацию о использовании для {partition.mountpoint}: {e}")
    print("-" * 105)
    return disk_usage_list # Возвращаем список использований дисков для анализа

def get_network_info():
    """Собирает информацию о сетевых интерфейсах."""
    print("="*40, "Сетевые Параметры", "="*40)
    if_addrs = psutil.net_if_addrs()
    for interface_name, interface_addresses in if_addrs.items():
        print(f"--- Интерфейс: {interface_name} ---")
        for address in interface_addresses:
            if str(address.family) == 'AddressFamily.AF_INET': # IPv4
                print(f"  IP Адрес (IPv4):  {address.address}")
                print(f"  Маска подсети:    {address.netmask}")
                print(f"  Широковещательный:{address.broadcast}")
            elif str(address.family) == 'AddressFamily.AF_INET6': # IPv6
                 print(f"  IP Адрес (IPv6):  {address.address}")
            elif str(address.family) == 'AddressFamily.AF_PACKET' or str(address.family) == 'socket.AF_LINK': # MAC (Linux/macOS vs Windows)
                # psutil < 5.4.0 used AF_LINK, >= 5.4.0 uses AF_PACKET on Linux/macOS
                # На Windows MAC адрес может не отображаться через этот метод для всех интерфейсов
                if address.address and len(address.address) == 17 and address.address.count(':') == 5: # Простая проверка формата MAC
                     print(f"  MAC Адрес:        {address.address}")
                     # print(f"  Маска подсети:    {address.netmask}") # Обычно None для MAC
                     # print(f"  Широковещательный:{address.broadcast}") # Обычно None для MAC

    # Можно добавить статистику I/O, но она может быть объемной
    # net_io = psutil.net_io_counters()
    # print(f"\n--- Общая сетевая статистика ---")
    # print(f"Всего байт отправлено: {get_size(net_io.bytes_sent)}")
    # print(f"Всего байт получено:   {get_size(net_io.bytes_recv)}")
    print("-" * 105)

# --- Функция анализа и выявления проблем ---

def analyze_system(cpu_usage, memory_usage, disk_usages):
    """
    Анализирует собранные метрики и выводит предупреждения о потенциальных проблемах.
    Возвращает условный "процент поломки" (скорее, уровень нагрузки/риска).
    """
    print("="*40, "Анализ Системы и Проблемные Области", "="*40)
    problems = []
    stress_score = 0 # Условный балл нагрузки/риска (0-100)
    factors_count = 0

    # Пороги для предупреждений (можно настроить)
    CPU_WARN_THRESHOLD = 85.0
    MEM_WARN_THRESHOLD = 90.0
    DISK_WARN_THRESHOLD = 90.0 # Процент использования диска

    # Анализ CPU
    if cpu_usage > CPU_WARN_THRESHOLD:
        problems.append(f"[ПРЕДУПРЕЖДЕНИЕ] Высокая загрузка CPU: {cpu_usage:.1f}% (Порог: {CPU_WARN_THRESHOLD}%)")
        stress_score += cpu_usage # Добавляем процент как вклад в общую оценку
    else:
        stress_score += cpu_usage / 2 # Меньший вклад, если не критично
    factors_count += 1

    # Анализ Памяти
    if memory_usage > MEM_WARN_THRESHOLD:
         problems.append(f"[ПРЕДУПРЕЖДЕНИЕ] Высокое использование оперативной памяти: {memory_usage:.1f}% (Порог: {MEM_WARN_THRESHOLD}%)")
         stress_score += memory_usage
    else:
        stress_score += memory_usage / 2
    factors_count += 1

    # Анализ Дисков
    high_disk_usage_found = False
    max_disk_percent = 0
    for disk in disk_usages:
        if disk["percent"] > DISK_WARN_THRESHOLD:
             problems.append(f"[ПРЕДУПРЕЖДЕНИЕ] Мало места на диске '{disk['mountpoint']}': {disk['percent']:.1f}% использовано ({disk['used']}/{disk['total']}) (Порог: {DISK_WARN_THRESHOLD}%)")
             high_disk_usage_found = True
        # Находим максимальное использование диска для оценки нагрузки
        if disk["percent"] > max_disk_percent:
            max_disk_percent = disk["percent"]

    # Добавляем максимальный процент использования диска к оценке
    if high_disk_usage_found:
        stress_score += max_disk_percent # Полный вклад, если есть проблема
    else:
         stress_score += max_disk_percent / 2 # Меньший вклад, если все ок
    if disk_usages: # Учитываем диски, только если они были найдены
         factors_count += 1


    # Вывод результатов анализа
    if problems:
        print("Обнаружены потенциальные проблемы:")
        for problem in problems:
            print(f"  - {problem}")
    else:
        print("Потенциальных проблем с производительностью (CPU, RAM, Disk Space) не обнаружено.")

    # Расчет и вывод "процента поломки" (уровня стресса)
    # Это очень упрощенная и условная метрика!
    if factors_count > 0:
        overall_stress_percentage = stress_score / factors_count
        print(f"\nУсловный уровень нагрузки системы: {overall_stress_percentage:.1f}%")
        if overall_stress_percentage > 75:
            print(">>> Система находится под высокой нагрузкой! <<<")
        elif overall_stress_percentage > 50:
            print(">>> Система находится под умеренной нагрузкой. <<<")
    else:
        print("\nНедостаточно данных для расчета уровня нагрузки.")

    print("-" * 105)


# --- Основной блок выполнения ---
if __name__ == "__main__":
    try:
        get_system_info()
        cpu_load = get_cpu_info()
        mem_load = get_memory_info()
        disk_loads = get_disk_info()
        get_network_info()
        analyze_system(cpu_load, mem_load, disk_loads)

    except Exception as e:
        print(f"\n[ОШИБКА] Произошла непредвиденная ошибка при сборе информации: {e}")
        import traceback
        traceback.print_exc() # Вывод стека вызовов для отладки

    # Добавим паузу в конце для Windows, чтобы окно не закрывалось сразу
    if sys.platform == "win32":
        os.system("pause")
